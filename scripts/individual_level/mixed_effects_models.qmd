---
title: "Individual-level analysis: mixed effects models"
subtitle: "Part of the final project for AQMSS II"
author: "Polikanov Stepan and Okisheva Vera"
format:
  pdf:
    fig-pos: "H"
    fontsize: 11pt
    highlight-style: kate
    fig-width: 10
    fig-height: 6
    include-in-header:
      - text: |
          \addtokomafont{disposition}{\rmfamily} 
          \AddToHook{env/Highlighting/begin}{\scriptsize} 
          \usepackage{float} 
          \usepackage[backend = biber, style = apa]{biblatex}
embed-resources: true
execute: 
  echo: true
  warning: false
  error: false
  message: false
---

# Mixed effects models

## Nested Logit

```{r}
#| label: packages
#| cache: false

source(here::here("utilities", "check_packages.R"))
source(here::here("utilities", "functions.R"))

conflicts_prefer(dplyr::filter)
```

```{r}
#| label: load-data

ep_raw_dep <- read_rds(here("data", "data_built", "ep_raw_dep.rds"))
data_country <- read_rds(here("data", "data_built", "data_country.rds"))
```

```{r}
#| label: load-models

load(here("scripts", "models", "feme_bobyqa.RData"))
load(here("scripts", "models", "nlme_bobyqa.RData"))
load(here("scripts", "models", "me_allfit.RData"))
load(here("scripts", "models", "nl_fe.RData"))
```

```{r}
#| label: prep-model-data

# Recode no data back to native NA
model_data <- ep_raw_dep |> 
  mutate(across(c(sex, age_bin, time_to_vs.less_than_hour, 
                  time_to_vs.less_than_hour, out_of_Russia_time, 
                  result_trust_bin), 
                ~ if_else(. %in% c("No Data", "Declined to answer"), NA, .)),
         vote = relevel(as.factor(vote), ref = "Putin"),
         sex = relevel(as.factor(sex), ref = "Male"),
         age_bin = relevel(as.factor(age_bin), ref = "25-44"),
         out_of_Russia_time = relevel(as.factor(out_of_Russia_time), ref = "Before annexation"),
         result_trust_bin = relevel(as.factor(result_trust_bin), ref = "Yes")) |> 
  filter(!countryname_en %in% c("New Zealand", "Australia"))
```

```{r}
#| label: prep-nested-logit-mixed-effects
#| cache: true

# Drop Australia and New Zealand for this because they have very skewed and low 
# n observations. Might also help with convergence
nested_me_data <- model_data |>
  filter(vote != "Tore up/took", !countryname_en %in% c("Australia",
                                                        "New Zealand")) |>
  mutate(non_answer = if_else(vote == "Declined to answer", 1, 0),
         putin_else = case_when(vote == "Putin" ~ 1,
                                vote %in% c("Davankov", "Spoiled ballot",
                                            "Slutsky", "Haritonov") ~ 0,
                                .default = NA),
         nonsys_sys = case_when(vote %in% c("Davankov", "Spoiled ballot") ~ 1,
                                vote %in% c("Slutsky", "Haritonov") ~ 0,
                                .default = NA),
         davankov_spoiled = case_when(vote == "Davankov" ~ 1,
                                      vote == "Spoiled ballot" ~ 0,
                                      .default = NA),
         slutsky_haritonov = case_when(vote == "Slutsky" ~ 1,
                                       vote == "Haritonov" ~ 0,
                                       .default = NA)) |> 
  left_join(select(data_country,
                   -countryname_en), 
            by = c("countrycode_n", "countrycode_c"))
```

We fit the model consecutively for each dichotomy this time separating data by hand in the same way as the ``nestedLogit`` package does.

For some models we get non-convergence. We diagnose which optimizers work best in those case and update the model to achieve convergence.

```{r}
#| label: nested-logit-mixed-effects-m4a-answer
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

# Answer (1) vs non-answer (0)
m4a.nested <- glmer(non_answer ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa"))

```

### Not answer v answer

```{r}
#| label: nested-logit-mixed-effects-m5a-answer-lvl2
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

# Use bobyqa
m5a.nested <- glmer(non_answer ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + orthodox_share + vdem_polyarchy_2022 
                    + log(mad_gdppc_2018) + obl_type + export_share
                    + import_share + friendly_status + help + military_dummy
                    + log(dist) + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa",
                                           optCtrl = list(maxfun = 1e9)))

# Doesn't converge
```

```{r}
#| label: nested-logit-mixed-effects-m5a-answer-lvl2-allfit
#| cache: true
#| dependson: nested-logit-mixed-effects-m5a-answer-lvl2

# Fit with all optimizers
m5a.allfit <- allFit(m5a.nested, maxfun = 1e9)
```

```{r}
#| label: nested-logit-mixed-effects-m5a-answer-lvl2-diagnostics
#| cache: true
#| dependson: nested-logit-mixed-effects-m5a-answer-lvl2-allfit
#| fig-height: 10

# Convergence results
  
  ## Export models
  m5a.allfit_OK <- m5a.allfit[sapply(m5a.allfit, is, "merMod")]
  
  ## Generate warnings encountered
  data.frame(lapply(m5a.allfit_OK, function(x) x@optinfo$conv$lme4$messages)) |> 
    pivot_longer(everything(), names_to = "Method",
                 values_to = "Estimation result") |> 
    arrange(`Method`, `Estimation result`) |> 
    distinct() |> 
    mutate(`Method` = if_else(lag(`Method`) != `Method` | is.na(lag(`Method`)), 
                              `Method`, ""),
           `Estimation result` = gsub("\\|", " ", `Estimation result`)) |> 
    kable(booktabs = T,
          caption = paste("Convergence results for Answer/non-Answer dichotomy,", 
                          "ME with level 2 variables and all optimizers")) |> 
    column_spec(1, width = "8cm") |> 
    column_spec(2, width = "8cm")

# Log-Likelihoods
(lliks <- sort(sapply(m5a.allfit_OK, logLik))) |> 
  kable(col.names = "Log-likelihood", booktabs = T, digits = 3)

# Coefficients from different optimizers
  
  ## Export fixef and melt into single dataframe
  models <- levels(melt(t(sapply(m5a.allfit_OK, fixef)))$Var1)
  m5a.allfit.fixef.m <- transform(melt(t(sapply(m5a.allfit_OK, fixef))), 
                                  Var1 = factor(Var1, levels = names(lliks))) |> 
    transmute(`Method` = Var1,
              `Coefficient` = value,
              `Variable` = case_when(
                Var2 == "(Intercept)" ~ "Intercept",
                Var2 == "sexFemale" ~ "Sex: Female",
                Var2 == "sexOther" ~ "Sex: Other",
                Var2 == "age_bin18-24" ~ "Age: 18-24 (ref 25-44)",
                Var2 == "age_bin45-64" ~ "Age: 45-65 (ref 25-44)",
                Var2 == "age_bin65+" ~ "Age: 65 + (ref 25-44)",
                Var2 == "time_to_vs.less_than_hourYes" ~ 
                  "Took < 1 hour to get to the voting station",
                Var2 == "out_of_Russia_timeAfter invasion" ~
                  "Moved after March 2022 (ref before 2014)",
                Var2 == "out_of_Russia_time2 - 5 years" ~
                  paste("Moved after March 2019 but before",
                        "March 2022 (ref before 2014)"),
                Var2 == "out_of_Russia_timeAfter annexation" ~
                  paste("Moved after March 2014 but before",
                        "March 2019 (ref before 2014)"),
                Var2 == "out_of_Russia_timeTourist (lives in Russia)" ~
                  paste("Didn't move - tourist, lives",
                        "in Russia (ref before 2014)"),
                Var2 == "result_trust_binDon't know" ~
                  "Trust in the result: Don't know (ref Yes)",
                Var2 == "result_trust_binNo" ~
                  "Trust in the result: No (ref Yes)",
                Var2 == "orthodox_share" ~ "Share of Orthodox Christians",
                Var2 == "vdem_polyarchy_2022" ~ "Polyarchy index",
                Var2 == "log(mad_gdppc_2018)" ~ "GDP per capita (log)",
                Var2 == "obl_type1" ~ "Military agreements: 1 (ref 0)",
                Var2 == "obl_type2" ~ "Military agreements: 2 (ref 0)",
                Var2 == "obl_type3" ~ "Military agreements: 3 (ref 0)",
                Var2 == "obl_type4" ~ "Military agreements: 4 (ref 0)",
                Var2 == "export_share" ~ "Export share",
                Var2 == "import_share" ~ "Import share",
                Var2 == "friendly_statusUnfriendly" ~ 
                  "Unfriendly status (ref Neutral)",
                Var2 == "friendly_statusFriendly" ~ 
                  "Friendly status (ref Neutral)",
                Var2 == "help" ~ "Help to Ukraine",
                Var2 == "military_dummy" ~ "Russian military presence",
                Var2 == "log(dist)" ~ "Geodesic distance (log)"),
              )
  
  ## Plot 
  ggplot(m5a.allfit.fixef.m, 
           aes(x = `Coefficient`, y = `Method`, colour = `Method`)) +
      geom_point() +
      facet_wrap(~ `Variable`, scale = "free") +
      scale_colour_brewer(palette = "Dark2") +
      scale_y_discrete(breaks = models,
                       labels = substr(models, 1, 3)) +
      labs(x = "", y = "") + 
      theme_minimal() +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 45, hjust = 1))

# So judging by this I leave the model alone - the coefficients seem to be okay 
# between different optimizers and since bobyqa comes close to the tolerance 
# threshold, I will use it.

# Check m5a-specific diagnostics
# Gradient 1
  derivs1 <- m5a.nested@optinfo$derivs
  sc_grad1 <- with(derivs1, solve(Hessian, gradient))
  gradres1 <- max(pmin(abs(sc_grad1), abs(derivs1$gradient)))

# Gradient 2
  dd <- update(m5a.nested, devFunOnly = TRUE)
  pars <- unlist(getME(m5a.nested, c("theta", "fixef")))
  grad2 <- grad(dd, pars)
  hess2 <- hessian(dd, pars)
  sc_grad2 <- solve(hess2, grad2)
  gradres2 <- max(pmin(abs(sc_grad2), abs(grad2)))

  ## The gradient cutoffs for Nelder Mead (nlopt), bobyqa and nlminwrap seem to 
  ## be close to what I am getting. 

# Check for singular fit 
singres <- if_else(isSingular(m5a.nested), "Yes", "No")
  
# Display diagnostics
kable(cbind(gradres1, gradres2, singres), 
      booktabs = T, digits = 3,
      col.names = c("Gradient, method I", "Gradient, method II", 
                    "Singular fit?"),
      caption = paste("Diagnostics for `Answer vs No answer to poll`", 
                      "model (with preferred optimizer)"))
```

The model doesn't converge. 

### Putin v everyone else

```{r}
#| label: nested-logit-mixed-effects-m4p-putin
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

# Putin (1) vs everyone else (0), declined to answer NA
m4p.nested <- glmer(putin_else ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa"))

# Converges!
```

```{r}
#| label: nested-logit-mixed-effects-m5p-putin-lvl2
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

m5p.nested <- glmer(putin_else ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + orthodox_share + vdem_polyarchy_2022 
                    + log(mad_gdppc_2018) + obl_type + export_share
                    + import_share + friendly_status + help + military_dummy
                    + log(dist) + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa", 
                                           optCtrl = list(maxfun = 1e9)))
```

```{r}
#| label: nested-logit-mixed-effects-m5p-putin-lvl2-allfit
#| cache: true
#| dependson: nested-logit-mixed-effects-m5p-putin-lvl2

# Fit with all optimizers (loaded with other models)
m5p.allfit <- allFit(m5p.nested, maxfun = 1e9)
```

```{r}
#| label: nested-logit-mixed-effects-m5p-putin-lvl2-diagnostics
#| cache: true
#| dependson: nested-logit-mixed-effects-m5p-putin-lvl2-allfit
#| fig-height: 10

# Convergence results
  
  ## Export models
  m5p.allfit_OK <- m5p.allfit[sapply(m5p.allfit, is, "merMod")]
  
  ## Generate warnings encountered
  data.frame(lapply(m5p.allfit_OK, function(x) x@optinfo$conv$lme4$messages)) |> 
    pivot_longer(everything(), names_to = "Method",
                 values_to = "Estimation result") |> 
    arrange(`Method`, `Estimation result`) |> 
    distinct() |> 
    mutate(`Method` = if_else(lag(`Method`) != `Method` | is.na(lag(`Method`)), 
                              `Method`, ""),
           `Estimation result` = gsub("\\|", " ", `Estimation result`)) |> 
    kable(booktabs = T,
          caption = paste("Convergence results for Answer/non-Answer dichotomy,", 
                          "ME with level 2 variables and all optimizers")) |> 
    column_spec(1, width = "8cm") |> 
    column_spec(2, width = "8cm")

# Log-Likelihoods
(lliks <- sort(sapply(m5p.allfit_OK, logLik))) |> 
  kable(col.names = "Log-likelihood", booktabs = T, digits = 3)

# Coefficients from different optimizers
  
  ## Export fixef and melt into single dataframe
  models <- levels(melt(t(sapply(m5p.allfit_OK, fixef)))$Var1)
  m5p.allfit.fixef.m <- transform(melt(t(sapply(m5p.allfit_OK, fixef))), 
                                  Var1 = factor(Var1, levels = names(lliks))) |> 
    transmute(`Method` = Var1,
              `Coefficient` = value,
              `Variable` = case_when(
                Var2 == "(Intercept)" ~ "Intercept",
                Var2 == "sexFemale" ~ "Sex: Female",
                Var2 == "sexOther" ~ "Sex: Other",
                Var2 == "age_bin18-24" ~ "Age: 18-24 (ref 25-44)",
                Var2 == "age_bin45-64" ~ "Age: 45-65 (ref 25-44)",
                Var2 == "age_bin65+" ~ "Age: 65 + (ref 25-44)",
                Var2 == "time_to_vs.less_than_hourYes" ~ 
                  "Took < 1 hour to get to the voting station",
                Var2 == "out_of_Russia_timeAfter invasion" ~
                  "Moved after March 2022 (ref before 2014)",
                Var2 == "out_of_Russia_time2 - 5 years" ~
                  paste("Moved after March 2019 but before",
                        "March 2022 (ref before 2014)"),
                Var2 == "out_of_Russia_timeAfter annexation" ~
                  paste("Moved after March 2014 but before",
                        "March 2019 (ref before 2014)"),
                Var2 == "out_of_Russia_timeTourist (lives in Russia)" ~
                  paste("Didn't move - tourist, lives",
                        "in Russia (ref before 2014)"),
                Var2 == "result_trust_binDon't know" ~
                  "Trust in the result: Don't know (ref Yes)",
                Var2 == "result_trust_binNo" ~
                  "Trust in the result: No (ref Yes)",
                Var2 == "orthodox_share" ~ "Share of Orthodox Christians",
                Var2 == "vdem_polyarchy_2022" ~ "Polyarchy index",
                Var2 == "log(mad_gdppc_2018)" ~ "GDP per capita (log)",
                Var2 == "obl_type1" ~ "Military agreements: 1 (ref 0)",
                Var2 == "obl_type2" ~ "Military agreements: 2 (ref 0)",
                Var2 == "obl_type3" ~ "Military agreements: 3 (ref 0)",
                Var2 == "obl_type4" ~ "Military agreements: 4 (ref 0)",
                Var2 == "export_share" ~ "Export share",
                Var2 == "import_share" ~ "Import share",
                Var2 == "friendly_statusUnfriendly" ~ 
                  "Unfriendly status (ref Neutral)",
                Var2 == "friendly_statusFriendly" ~ 
                  "Friendly status (ref Neutral)",
                Var2 == "help" ~ "Help to Ukraine",
                Var2 == "military_dummy" ~ "Russian military presence",
                Var2 == "log(dist)" ~ "Geodesic distance (log)"),
              )
  
  ## Plot
  ggplot(m5p.allfit.fixef.m, 
         aes(x = `Coefficient`, y = `Method`, colour = `Method`)) +
      geom_point() +
      facet_wrap(~ `Variable`, scale = "free") +
      scale_colour_brewer(palette = "Dark2") +
      scale_y_discrete(breaks = models,
                       labels = substr(models, 1, 3)) +
      labs(x = "", y = "") + 
      theme_minimal() +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 45, hjust = 1))

# Check m5p-specific diagnostics
  
# Gradient 1
  derivs1 <- m5p.nested@optinfo$derivs
  sc_grad1 <- with(derivs1, solve(Hessian, gradient))
  gradres1 <- max(pmin(abs(sc_grad1), abs(derivs1$gradient)))

# Gradient 2
  dd <- update(m5p.nested, devFunOnly = TRUE)
  pars <- unlist(getME(m5p.nested, c("theta", "fixef")))
  grad2 <- grad(dd, pars)
  hess2 <- hessian(dd, pars)
  sc_grad2 <- solve(hess2, grad2)
  gradres2 <- max(pmin(abs(sc_grad2), abs(grad2)))

  ## The gradient cutoffs for Nelder Mead (nlopt), bobyqa and nlminwrap seem to 
  ## be close to what I am getting. 

# Check for singular fit 
singres <- if_else(isSingular(m5p.nested), "Yes", "No")
  
# Display diagnostics
kable(cbind(gradres1, gradres2, singres),
      booktabs = T, digits = 3,
      col.names = c("Gradient, method I", "Gradient, method II", 
                    "Singular fit?"),
      caption = paste("Diagnostics for `Putin vs Everyone", 
                      "else` model (with preferred optimizer)"))
```

### Non-systemic v systemic opposition

```{r}
#| label: nested-logit-mixed-effects-m4s-systemic
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

# Non-systemic - Davankov or Spoiled (1) vs systemic - Haritonov, Slutsky (0) 
# opposition, declined to answer and Putin are NA
m4s.nested <- glmer(nonsys_sys ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa"))

# Converges
```

```{r}
#| label: nested-logit-mixed-effects-m4s-systemic-lvl2
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

m5s.nested <- glmer(nonsys_sys ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + orthodox_share + vdem_polyarchy_2022 
                    + log(mad_gdppc_2018) + obl_type + export_share
                    + import_share + friendly_status  + help + military_dummy
                    + log(dist) + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa", 
                                           optCtrl = list(maxfun = 1e9)))

# Singular fit! 

# The predictors most likely to cause issues are obl_type and friendly_status
# as they are broadly (and correlated between themselves and other variables) 
# defined dichotomous predictors. Remove them from the model and try again
```

```{r}
#| label: nested-logit-mixed-effects-m4s-systemic-lvl2-red
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

m5s.red <- update(m5s.nested, ~ . - obl_type - friendly_status)

# Works great and no issues with convergence either
```


### Davankov v spoiled

```{r}
#| label: nested_logit_mixed_effects_m4d_davankov
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

# Davankov (1) vs Spoiled (0) declined to answer, Haritonov, Slutsky and Putin
# are NA
m4d.nested <- glmer(davankov_spoiled ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa"))
```

```{r}
#| label: nested_logit_mixed_effects_m5d_davankov_lvl2
#| cache: true
#| dependson: prep-nested-logit-mixed-effects

m5d.nested <- glmer(davankov_spoiled ~ sex + age_bin + time_to_vs.less_than_hour
                    + out_of_Russia_time + result_trust_bin
                    + orthodox_share + vdem_polyarchy_2022 
                    + log(mad_gdppc_2018) + obl_type + export_share
                    + import_share + friendly_status  + help + military_dummy
                    + log(dist) + (1 | countryname_en), 
                    data = nested_me_data, family = binomial,
                    control = glmerControl(optimizer = "bobyqa", 
                                           optCtrl = list(maxfun = 1e9)))
```

```{r}
#| label: nested_logit_mixed_effects_m5d_davankov_lvl2_allfit
#| cache: true
#| dependson: nested_logit_mixed_effects_m5d_davankov_lvl2
m5d.allfit <- allFit(m5d.nested, maxfun = 1e9)
```

```{r}
#| label: nested_logit_mixed_effects_m5d_davankov_lvl2_diagnostics
#| cache: true
#| dependson: nested_logit_mixed_effects_m5d_davankov_lvl2_allfit
#| fig-height: 10

# Convergence results
  
  ## Export models
  m5d.allfit_OK <- m5d.allfit[sapply(m5d.allfit, is, "merMod")]
  
  ## Generate warnings encountered
  data.frame(lapply(m5d.allfit_OK, function(x) x@optinfo$conv$lme4$messages)) |> 
    pivot_longer(everything(), names_to = "Method",
                 values_to = "Estimation result") |> 
    arrange(`Method`, `Estimation result`) |> 
    distinct() |> 
    mutate(`Method` = if_else(lag(`Method`) != `Method` | is.na(lag(`Method`)), 
                              `Method`, ""),
           `Estimation result` = gsub("\\|", " ", `Estimation result`)) |> 
    kable(booktabs = T,
          caption = paste("Convergence results for Answer/non-Answer dichotomy,", 
                          "ME with level 2 variables and all optimizers")) |> 
    column_spec(1, width = "8cm") |> 
    column_spec(2, width = "8cm")

# Log-Likelihoods
(lliks <- sort(sapply(m5d.allfit_OK, logLik))) |> 
  kable(col.names = "Log-likelihood", booktabs = T, digits = 3)

# Coefficients from different optimizers
  
  ## Export fixef and melt into single dataframe
  models <- levels(melt(t(sapply(m5d.allfit_OK, fixef)))$Var1)
  m5d.allfit.fixef.m <- transform(melt(t(sapply(m5d.allfit_OK, fixef))), 
                                  Var1 = factor(Var1, levels = names(lliks))) |> 
    transmute(`Method` = Var1,
              `Coefficient` = value,
              `Variable` = case_when(
                Var2 == "(Intercept)" ~ "Intercept",
                Var2 == "sexFemale" ~ "Sex: Female",
                Var2 == "sexOther" ~ "Sex: Other",
                Var2 == "age_bin18-24" ~ "Age: 18-24 (ref 25-44)",
                Var2 == "age_bin45-64" ~ "Age: 45-65 (ref 25-44)",
                Var2 == "age_bin65+" ~ "Age: 65 + (ref 25-44)",
                Var2 == "time_to_vs.less_than_hourYes" ~ 
                  "Took < 1 hour to get to the voting station",
                Var2 == "out_of_Russia_timeAfter invasion" ~
                  "Moved after March 2022 (ref before 2014)",
                Var2 == "out_of_Russia_time2 - 5 years" ~
                  paste("Moved after March 2019 but before",
                        "March 2022 (ref before 2014)"),
                Var2 == "out_of_Russia_timeAfter annexation" ~
                  paste("Moved after March 2014 but before",
                        "March 2019 (ref before 2014)"),
                Var2 == "out_of_Russia_timeTourist (lives in Russia)" ~
                  paste("Didn't move - tourist, lives",
                        "in Russia (ref before 2014)"),
                Var2 == "result_trust_binDon't know" ~
                  "Trust in the result: Don't know (ref Yes)",
                Var2 == "result_trust_binNo" ~
                  "Trust in the result: No (ref Yes)",
                Var2 == "orthodox_share" ~ "Share of Orthodox Christians",
                Var2 == "vdem_polyarchy_2022" ~ "Polyarchy index",
                Var2 == "log(mad_gdppc_2018)" ~ "GDP per capita (log)",
                Var2 == "obl_type1" ~ "Military agreements: 1 (ref 0)",
                Var2 == "obl_type2" ~ "Military agreements: 2 (ref 0)",
                Var2 == "obl_type3" ~ "Military agreements: 3 (ref 0)",
                Var2 == "obl_type4" ~ "Military agreements: 4 (ref 0)",
                Var2 == "export_share" ~ "Export share",
                Var2 == "import_share" ~ "Import share",
                Var2 == "friendly_statusUnfriendly" ~ 
                  "Unfriendly status (ref Neutral)",
                Var2 == "friendly_statusFriendly" ~ 
                  "Friendly status (ref Neutral)",
                Var2 == "help" ~ "Help to Ukraine",
                Var2 == "military_dummy" ~ "Russian military presence",
                Var2 == "log(dist)" ~ "Geodesic distance (log)"),
              )
  
  ## Plot
  ggplot(m5d.allfit.fixef.m, 
           aes(x = `Coefficient`, y = `Method`, colour = `Method`)) +
      geom_point() +
      facet_wrap(~ `Variable`, scale = "free") +
      scale_colour_brewer(palette = "Dark2") +
      scale_y_discrete(breaks = models,
                       labels = substr(models, 1, 3)) +
      labs(x = "", y = "") + 
      theme_minimal() +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 45, hjust = 1))

# Check m5d-specific diagnostics
  
# Gradient 1
  derivs1 <- m5d.nested@optinfo$derivs
  sc_grad1 <- with(derivs1, solve(Hessian, gradient))
  gradres1 <- max(pmin(abs(sc_grad1), abs(derivs1$gradient)))

# Gradient 2
  dd <- update(m5d.nested, devFunOnly = TRUE)
  pars <- unlist(getME(m5d.nested, c("theta", "fixef")))
  grad2 <- grad(dd, pars)
  hess2 <- hessian(dd, pars)
  sc_grad2 <- solve(hess2, grad2)
  gradres2 <- max(pmin(abs(sc_grad2), abs(grad2)))

  ## The gradient cutoffs for Nelder Mead (nlopt), bobyqa and nlminwrap seem to 
  ## be close to what I am getting. 

# Check for singular fit 
singres <- if_else(isSingular(m5d.nested), "Yes", "No")
  
# Display diagnostics
kable(cbind(gradres1, gradres2, singres), 
      booktabs = T, digits = 3,
      col.names = c("Gradient, method I", "Gradient, method II", 
                    "Singular fit?"),
      caption = paste("Diagnostics for `Davankov vs Spoil the ballot`", 
                      "model (with preferred optimizer)"))
```

```{r}
#| label: save-mixed-effects-models

save(list = c("m5a.nested", "m5p.nested", "m5s.nested", "m5s.red", "m5d.nested"), 
     file = "nlme_bobyqa.RData")

save(list = c("m4a.nested", "m4p.nested", "m4s.nested", "m4d.nested"), 
     file = "feme_bobyqa.RData")

save(list = c("m5a.allfit", "m5p.allfit", "m5d.allfit"), 
     file = "me_allfit.RData")
```

```{r}
#| label: prep-models-labels

coef_map_me <- c("(Intercept)", "sexFemale" = "Sex: Female", 
                 "sexOther" = "Sex: Other", 
                 "age_bin18-24" = "Age: 18-24 (ref 25-44)", 
                 "age_bin45-64" = "Age: 45-65 (ref 25-44)", 
                 "age_bin65+" = "Age: 65 + (ref 25-44)", 
                 "time_to_vs.less_than_hourYes" = 
                   "Took < 1 hour to get to the voting station",
                 "out_of_Russia_timeAfter invasion" =
                   "Moved after March 2022 (ref before 2014)", 
                 "out_of_Russia_time2 - 5 years" = 
                   paste("Moved after March 2019 but before",
                         "March 2022 (ref before 2014)"),
                 "out_of_Russia_timeAfter annexation" =
                   paste("Moved after March 2014 but before",
                         "March 2019 (ref before 2014)"),
                 "out_of_Russia_timeTourist (lives in Russia)" =
                   paste("Didn't move - tourist, lives",
                         "in Russia (ref before 2014)"),
                 "result_trust_binDon't know" = 
                   "Trust in the result: Don't know (ref Yes)",
                 "result_trust_binNo" = 
                   "Trust in the result: No (ref Yes)",
                 "orthodox_share" = "Share of Orthodox Christians",
                 "vdem_polyarchy_2022" = "Polyarchy index",
                 "log(mad_gdppc_2018)" = "GDP per capita (log)",
                 "obl_type1" = "Military agreements: 1 (ref 0)",
                 "obl_type2" = "Military agreements: 2 (ref 0)",
                 "obl_type3" = "Military agreements: 3 (ref 0)",
                 "obl_type4" = "Military agreements: 4 (ref 0)",
                 "export_share" = "Export share",
                 "import_share" = "Import share",
                 "friendly_statusUnfriendly" = 
                   "Unfriendly status (ref Neutral)",
                 "friendly_statusFriendly" =
                   "Friendly status (ref Neutral)",
                 "help" = "Help to Ukraine",
                 "military_dummy" = "Russian military presence",
                 "log(dist)" = "Geodesic distance (log)")
```

```{r}
#| label: tbl-results-me-1
#| tbl-cap: "Mixed effects results, no level 2 variables"

modelsummary(list("Declined to answer vs answer" = m4a.nested,
                  "Putin vs everyone else" = m4p.nested,
                  "Non-systemic vs systemic opposition" = m4s.nested,
                  "Davankov vs Spoiled" = m4d.nested),
             output = "kableExtra", stars = T, 
             coef_map = coef_map_me) |> 
  kable_styling(latex_options = "scale_down")
```

```{r}
#| label: tbl-results-me-2
#| tbl-cap: "Comparison: logistic vs mixed effects models (no lvl 2 variables)"

m3.answer <- models(m3.nested.fe, 1)
m3.putin <- models(m3.nested.fe, 2)
m3.nonsys <- models(m3.nested.fe, 3)
m3.davankov <- models(m3.nested.fe, 4)

modelsummary(list("Logistic" = m3.answer,
                  "Mixed effects" = m4a.nested,
                  "Logistic" = m3.putin,
                  "Mixed effects" = m4p.nested,
                  "Logistic" = m3.nonsys,
                  "Mixed effects" = m4s.nested,
                  "Logistic" = m3.davankov,
                  "Mixed effects" = m4d.nested),
             output = "kableExtra", stars = T, 
             coef_map = coef_map_me) |> 
  kable_styling(latex_options = "scale_down") |> 
  add_header_above(c(" " = 1, "Answer vs No answer" = 2, 
                     "Putin vs everyone else" = 2,
                     "Non-systemic vs systemic opposition" = 2,
                     "Davankov vs Spoiled" = 2))
```

```{r}
#| label: tbl-results-me-3
#| tbl-cap: "Mixed effects results, with level 2 variables"

modelsummary(list("Declined to answer vs answer" = m5a.nested,
                  "Putin vs everyone else" = m5p.nested,
                  "Non-systemic vs systemic opposition" = m5s.red,
                  "Davankov vs Spoiled" = m5d.nested),
             output = "kableExtra", stars = T, 
             coef_map = coef_map_me) |> 
  kable_styling(latex_options = "scale_down")
```

```{r}
#| label: tbl-results-me-4
#| tbl-cap: "Comparison: mixed effects (no lvl 2) vs mixed effects models (with lvl 2)"

modelsummary(list("No lvl 2" = m4a.nested,
                  "With lvl 2" = m5a.nested,
                  "No lvl 2" = m4p.nested,
                  "With lvl 2" = m5p.nested,
                  "No lvl 2" = m4s.nested,
                  "With lvl 2" = m5s.red,
                  "No lvl 2" = m4d.nested,
                  "With lvl 2" = m5d.nested),
             output = "kableExtra", stars = T, 
             coef_map = coef_map_me) |> 
  kable_styling(latex_options = "scale_down") |> 
  add_header_above(c(" " = 1, "Answer vs No answer" = 2, 
                     "Putin vs everyone else" = 2,
                     "Non-systemic vs systemic opposition" = 2,
                     "Davankov vs Spoiled" = 2))
```
